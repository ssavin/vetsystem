Концептуальная Архитектура
Система будет состоять из трех основных частей: вашего существующего сервера, нового десктопного приложения и модуля синхронизации.

Основной Web-Сервер (Express.js): Остается "источником правды". Все полные данные хранятся здесь. Его нужно будет доработать, добавив API для синхронизации.

Десктопное Приложение-Компаньон: Легковесная программа, установленная на компьютерах в клинике. Она имеет собственную локальную базу данных.

Модуль Синхронизации: "Сердце" офлайн-режима. Отвечает за загрузку данных с сервера и отправку изменений, сделанных в офлайне, обратно на сервер.

Техническое Задание для AI-агента: Разработка Офлайн-Компаньона VetSystem
Общая цель: Создать десктопное приложение-компаньон для VetSystem, которое обеспечивает непрерывность критически важных операций (регистрация, прием, выставление счетов) при отсутствии или нестабильности интернет-соединения, с последующей синхронизацией данных.

Ключевой технологический выбор: Electron.js. Это лучший выбор для вас, так как он позволяет создавать настольные приложения с использованием веб-технологий (HTML, CSS, JavaScript/TypeScript). Ваша команда, знающая React, сможет очень быстро его освоить.

Часть 1: Проектирование Десктопного Приложения (Electron.js)
Приложение должно быть максимально простым и сфокусированным только на офлайн-задачах.

Основной интерфейс (UI):

Минималистичный дизайн: Используйте те же UI-компоненты (или их аналоги), что и в веб-версии, для единообразия.

Индикатор статуса: На видном месте всегда должен быть индикатор:

Зеленый: "Онлайн. Все данные синхронизированы."

Желтый: "Офлайн. Работа в локальном режиме. N записей ожидают синхронизации."

Красный: "Ошибка синхронизации."

Основные разделы: "Запись на прием", "Клиенты", "Счета".

Функционал:

Запись на прием: Возможность создать новый прием для существующего или нового клиента.

Клиенты: Поиск по локальной базе клиентов, создание нового клиента и пациента.

Счета: Создание счета на основе оказанных услуг, добавление услуг/товаров из локального прайс-листа, расчет итоговой суммы.

Печать: Возможность печатать счета и (если касса подключена локально) фискальные чеки.

Задача для AI (Десктоп):

Инициализируй новый проект с использованием Electron.js и TypeScript.

Создай базовую структуру интерфейса с индикатором статуса и тремя основными разделами.

Реализуй формы для создания клиента, пациента и счета, которые работают с локальной базой данных.

Часть 2: Локальная База Данных (SQLite)
Внутри Electron-приложения будет работать своя мини-база данных. SQLite — идеальный выбор: это легковесная, файловая СУБД, не требующая отдельного сервера.

Структура таблиц:

clients: Урезанная версия основной таблицы (только ФИО, телефон, email).

patients: Урезанная версия (кличка, вид, порода, связь с clients).

nomenclature: Полная копия прайс-листа (услуги и товары с ценами).

appointments: Таблица для хранения приемов, созданных в офлайне.

invoices: Таблица для счетов, созданных в офлайне.

sync_queue (Ключевая таблица!): Очередь действий, которые нужно отправить на сервер.

Таблица sync_queue:

id (PRIMARY KEY)

action_type (ENUM: 'create_client', 'create_patient', 'create_invoice')

payload (JSON, содержит все данные для создания объекта, например, { "name": "Иванов И.И.", "phone": "..." })

status (ENUM: 'pending', 'success', 'error'), default 'pending'

created_at (TIMESTAMP)

Задача для AI (Десктоп):

Интегрируй библиотеку sqlite3 в Electron-проект.

Напиши скрипты для создания (миграции) указанных выше таблиц при первом запуске приложения.

Часть 3: Логика Синхронизации
Это самая сложная и важная часть.

Первичная/Плановая Синхронизация ("Сверху вниз"):

Когда: При запуске приложения (если есть интернет) или по кнопке "Обновить данные".

Что происходит:

Приложение отправляет запрос на специальный API-эндпоинт на вашем основном сервере.

Сервер отдает полный список активных клиентов, пациентов и номенклатуры.

Приложение полностью очищает свои локальные таблицы clients, patients, nomenclature и заполняет их свежими данными.

Работа в офлайн-режиме:

Когда администратор создает нового клиента, в локальную таблицу clients добавляется запись.

Одновременно в таблицу sync_queue добавляется новая задача: action_type = 'create_client', payload = { ...данные нового клиента... }.

То же самое происходит при создании пациента, счета и т.д.

Синхронизация Изменений ("Снизу вверх"):

Когда: Автоматически, как только появляется интернет, или по кнопке "Синхронизировать".

Что происходит:

Приложение проверяет наличие записей в sync_queue со статусом pending.

Оно берет их пачками (например, по 10 штук) и отправляет на специальный API-эндпоинт на сервере.

Сервер обрабатывает каждую задачу из очереди: создает клиента, счет и т.д. в основной базе данных.

Сервер возвращает ответ, для каких id из sync_queue операция прошла успешно.

Приложение обновляет статусы в своей локальной sync_queue на success или error.

Задача для AI (Десктоп):

Реализуй сервис SyncService в Electron-приложении.

Реализуй метод downloadInitialData() для синхронизации "сверху вниз".

Модифицируй логику создания клиентов/счетов так, чтобы они также создавали запись в sync_queue.

Реализуй метод uploadPendingChanges(), который будет в фоновом режиме проверять интернет и отправлять очередь на сервер.

Часть 4: Модификация Бэкенда (Express.js)
Ваш основной сервер должен научиться "разговаривать" с десктопным приложением.

Новый API Эндпоинт: GET /api/sync/initial-data

Описание: Отдает все данные для первичной синхронизации.

Логика: Делает запросы к БД для получения всех активных клиентов, пациентов и номенклатуры. Формирует большой JSON-ответ: { "clients": [...], "patients": [...], "nomenclature": [...] }.

Безопасность: Доступен только по специальному API-ключу, который будет зашит в десктопное приложение.

Новый API Эндпоинт: POST /api/sync/upload-changes

Описание: Принимает очередь изменений из десктопного приложения.

Request Body: { "actions": [ { "queue_id": 1, "action_type": "create_client", "payload": {...} }, ... ] }.

Логика:

Проходит в цикле по массиву actions.

Внутри транзакции базы данных выполняет соответствующие действия (создает клиента, счет и т.д.).

Формирует ответ со статусом по каждому queue_id: { "results": [ { "queue_id": 1, "status": "success" }, { "queue_id": 2, "status": "error", "message": "..." } ] }.

Задача для AI (Бэкенд):

Реализуй два новых API-эндпоинта с описанной логикой.

Обеспечь их защиту (например, через проверку статичного API-ключа в заголовках).

Пользовательский Workflow
Утром, при наличии интернета, администратор запускает десктопное приложение VetSystem Companion. Приложение автоматически скачивает актуальные списки клиентов и прайс-лист. Индикатор горит зеленым.

Интернет пропадает. Индикатор становится желтым. Администратор продолжает работать: ищет клиентов, создает новые записи, выписывает счета. Все операции происходят мгновенно, так как работают с локальной базой. В углу индикатора счетчик "Записей к синхронизации: 5".

Интернет появляется. Приложение автоматически обнаруживает соединение, начинает отправлять накопленные записи на сервер. Счетчик уменьшается.

Синхронизация завершена. Индикатор снова становится зеленым. Все данные, созданные в офлайне, теперь доступны в основной веб-версии программы.

Этот подход обеспечит 100% бесперебойность работы клиники в самых критичных операциях.