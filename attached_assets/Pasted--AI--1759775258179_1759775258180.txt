Техническое Задание для AI-агента: Модуль "Генерация и Печать Документов"
Цель: Разработать гибкий, мультитентный модуль для генерации и печати документов (счета, выписки, согласия и т.д.) на основе настраиваемых шаблонов. Система должна позволять суперадминистратору управлять базовыми шаблонами, а каждой клинике (арендатору) — кастомизировать их под свои нужды (например, добавлять свой логотип или реквизиты).

Часть 1: Проектирование Базы Данных (PostgreSQL / Drizzle ORM)
Необходимо создать новую таблицу для хранения шаблонов документов.

Модель document_templates (Шаблоны документов):

id (PRIMARY KEY, UUID)

tenant_id (FOREIGN KEY к tenants.id, может быть NULL)

Если tenant_id равен NULL, это системный (дефолтный) шаблон, управляемый суперадминистратором.

Если tenant_id указан, это кастомный шаблон для конкретной клиники-арендатора, который переопределяет системный.

name (VARCHAR, человекочитаемое название, напр. "Информированное согласие на анестезию")

type (ENUM, машиночитаемый тип шаблона). Возможные значения: 'invoice', 'encounter_summary', 'informed_consent_surgery', 'lab_results_report'.

content (TEXT, содержимое шаблона в формате HTML с плейсхолдерами Handlebars).

created_at, updated_at (TIMESTAMPS)

Задача для AI: На основе этого описания, создай миграцию Drizzle ORM для добавления таблицы document_templates в схему PostgreSQL. Добавь уникальный индекс на (tenant_id, type), чтобы у одной клиники не было двух шаблонов одного типа.

Часть 2: Технология и Логика Шаблонизации (Бэкенд)
Технология:

Шаблонизатор: Используем библиотеку Handlebars.js для рендеринга HTML на бэкенде. Она проста, быстра и использует интуитивно понятные плейсхолдеры {{переменная}}.

Генерация PDF: Используем библиотеку Puppeteer. Она позволяет "открыть" сгенерированный HTML в невидимом (headless) браузере Chrome на сервере и "распечатать" его в идеальный PDF, сохраняя все стили.

Логика выбора шаблона (Fallback Logic):

Когда поступает запрос на генерацию документа для tenant_id = X и type = Y:

Система сначала ищет в таблице document_templates запись, где tenant_id = X И type = Y.

Если находит — используется этот кастомный шаблон.

Если не находит — система ищет запись, где tenant_id IS NULL И type = Y. Используется системный шаблон по умолчанию.

Это позволяет суперадминистратору предоставлять готовые шаблоны для всех, а клиникам — переопределять только те, которые им нужны.

Часть 3: Архитектура Бэкенда (Express / TypeScript)
Необходимо создать универсальный API-эндпоинт для генерации всех типов документов.

API Эндпоинт: POST /api/documents/generate

Описание: Генерирует документ на основе шаблона и данных сущности.

Request Body:

JSON

{
  "templateType": "invoice", // Тип шаблона из ENUM
  "entityId": "uuid-of-the-appointment-or-case", // ID сущности (приема, случая, пациента)
  "outputFormat": "pdf" // или "html"
}
Валидация Zod: Создать схему для валидации этого Request Body.

Логика Контроллера:

Валидировать входящие данные.

Извлечь tenant_id из JWT-токена пользователя.

Собрать контекст данных: На основе entityId и templateType сделать необходимые запросы к базе данных, чтобы собрать все данные для шаблона. Например, для invoice нужно получить данные о клинике, владельце, пациенте, а также список всех услуг и товаров в счете с ценами. Все это упаковывается в один большой JSON-объект context.

Получить шаблон: Используя tenant_id и templateType, извлечь из БД нужный content шаблона (с учетом логики fallback).

Рендеринг HTML: С помощью Handlebars скомпилировать шаблон и передать в него context. const finalHtml = Handlebars.compile(templateContent)(context);

Генерация ответа:

Если outputFormat === 'html', отправить finalHtml с Content-Type: text/html.

Если outputFormat === 'pdf', передать finalHtml в Puppeteer, сгенерировать PDF-буфер и отправить его с Content-Type: application/pdf.

Обработать все возможные ошибки (шаблон не найден, сущность не найдена и т.д.).

Задача для AI: Установи handlebars и puppeteer. Создай роутер, контроллер и сервис для реализации эндпоинта POST /api/documents/generate. Реализуй логику сбора контекста данных (для начала можно сделать заглушку для invoice), выбора шаблона и рендеринга HTML/PDF.

Часть 4: Архитектура Фронтенда (React / TypeScript)
На фронтенде нужно создать универсальный компонент, который можно будет разместить в любом месте интерфейса для вызова печати.

Компонент PrintDocumentButton.tsx

Props (Свойства):

templateType: string (напр. 'invoice')

entityId: string (напр. ID текущего приема)

outputFormat?: 'pdf' | 'html' (по умолчанию 'pdf')

children: React.ReactNode (текст или иконка на кнопке)

UI: Используй компонент Button от Shadcn/ui. Добавь отображение спиннера (загрузки), пока документ генерируется.

Логика:

Используй хук useMutation от TanStack Query для вызова API.

При клике на кнопку:

Установить состояние isLoading = true.

Вызвать API-клиент для отправки запроса на POST /api/documents/generate с нужными props.

Важно: API-клиент должен быть настроен на получение ответа типа blob (бинарные данные), а не json.

Когда blob получен:

Создать временный URL для него: const url = URL.createObjectURL(blob);

Открыть этот URL в новой вкладке: window.open(url, '_blank');

Браузер сам откроет встроенный просмотрщик PDF или отобразит HTML.

Установить isLoading = false (даже в случае ошибки).

Задача для AI: Создай компонент PrintDocumentButton.tsx с описанной логикой. Модифицируй API-клиент, чтобы он мог обрабатывать blob ответы. Затем интегрируй эту кнопку в существующий интерфейс, например, на страницу "Клинический случай", добавив <PrintDocumentButton templateType="encounter_summary" entityId={caseId}>Печать выписки</PrintDocumentButton>.

