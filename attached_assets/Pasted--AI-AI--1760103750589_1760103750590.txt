Техническое Задание для AI-агента: Модуль "AI-Ассистент" в реальном времени
Общая цель: Интегрировать в VetSystem интеллектуального ассистента, который в реальном времени слушает разговор сотрудника с клиентом, понимает контекст и предлагает конкретные действия в интерфейсе программы (поиск пациента, заполнение полей, предложение свободных слотов в расписании и т.д.).

Ключевой принцип: AI не действует самостоятельно. Он предлагает действия, а сотрудник (администратор или врач) подтверждает их одним кликом. Это обеспечивает контроль и минимизирует ошибки.

Часть 1: Архитектура Бэкенда (Express / TypeScript)
Бэкенд будет отвечать за "мышление": получение транскрипта, его анализ с помощью Gemini и возврат структурированной команды на фронтенд.

Создание нового сервиса AIAssistantService.ts:

Назначение: Инкапсулировать всю логику работы с Gemini для задач ассистента.

Методы:

getCommandFromTranscript(transcript: string, role: 'admin' | 'doctor'): Основной метод. Принимает текст разговора и роль сотрудника, чтобы использовать правильный системный промпт. Возвращает объект команды (например, { action: 'OPEN_PATIENT_CARD', payload: { ... } }).

Создание нового API Эндпоинта: POST /api/ai/assistant-command

Описание: "Единая точка входа" для всех запросов от AI-ассистента на фронтенде.

Request Body:

JSON

{
  "transcript": "Полный текст разговора...",
  "role": "admin" // или "doctor"
}
Response Body (Примеры):

Для поиска/открытия карты:

JSON

{
  "action": "OPEN_PATIENT_CARD",
  "payload": {
    "ownerName": "Иванов Иван",
    "petName": "Барсик"
  }
}
Для заполнения полей:

JSON

{
  "action": "FILL_FORM_DATA",
  "payload": {
    "ownerPhone": "+79261234567",
    "anamnesis": "Хромота на правую переднюю лапу после прогулки."
  }
}
Для поиска свободного времени:

JSON

{
  "action": "FIND_APPOINTMENT_SLOT",
  "payload": {
    "doctorSpecialty": "хирург",
    "preferredDate": "завтра" // Gemini сам преобразует "завтра"
  }
}
Валидация Zod: Создать схемы для валидации входящего запроса и, по возможности, для исходящих ответов.

Задача для AI (Бэкенд):

Создай сервис AIAssistantService.ts и контроллер для эндпоинта POST /api/ai/assistant-command.

Интегрируй в сервис вызов Gemini API. Логика должна выбирать системный промпт в зависимости от role и отправлять транскрипт на анализ.

Настрой Gemini так, чтобы он всегда отвечал в формате JSON, как в примерах выше (используй responseMimeType: "application/json").

Часть 2: Архитектура Фронтенда (React / TypeScript)
Фронтенд отвечает за захват речи и отображение предложений от AI.

Создание хука useSpeechRecognition.ts:

Назначение: Изолировать логику работы с Web Speech API браузера.

Возвращаемые значения: { transcript, isListening, startListening, stopListening }.

Создание компонента AIAssistantWidget.tsx:

Назначение: Главный UI-компонент ассистента, который будет отображаться в углу экрана или рядом с активной формой.

UI и Состояния:

Состояние "Idle": Иконка микрофона. По клику — переход в "Listening".

Состояние "Listening": Микрофон анимируется. Отображается живой транскрипт речи. Повторный клик или пауза в речи — переход в "Processing".

Состояние "Processing": Показывается спиннер Loader2. В этот момент хук useMutation (TanStack Query) отправляет накопленный transcript на бэкенд (/api/ai/assistant-command).

Состояние "Suggestion": Отображается карточка Card от Shadcn/ui с предложением от AI.

Пример карточки-предложения:

Заголовок: "AI предлагает действие"

Содержимое: "Открыть карту пациента Барсик (Иванов Иван)?"

Действие: Кнопка Button "Выполнить". По клику фронтенд выполняет действие (например, переходит на страницу пациента).

Задача для AI (Фронтенд):

Реализуй хук useSpeechRecognition.ts.

Создай компонент AIAssistantWidget.tsx с описанными состояниями.

Используй useMutation для взаимодействия с бэкендом.

Реализуй логику отображения карточки с предложением на основе action из ответа API. При подтверждении действия — выполни его (например, используй setValue из React Hook Form для FILL_FORM_DATA или router.push для OPEN_PATIENT_CARD).

